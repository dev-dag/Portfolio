using UnityEngine;
using FluentBehaviourTree;
using System;

namespace Monster
{
    public class Boss : Monster, IInteractable, ICombatable
    {
        public enum Skill
        {
            None = 0,
            Slash,
            EjectSlash,
            Explosion,
            Rush,
        }

        public struct AnimHash
        {
            public static readonly int IDLE = Animator.StringToHash("Idle");
            public static readonly int MOVE = Animator.StringToHash("Move");
            public static readonly int DIE = Animator.StringToHash("Die");
            public static readonly int SLASH = Animator.StringToHash("Slash");
            public static readonly int EJECT_SLASH = Animator.StringToHash("Eject Slash");
            public static readonly int EXPLOSION = Animator.StringToHash("Explosion");
            public static readonly int RUSH = Animator.StringToHash("Rush");
            public static readonly int PHASE_EXIT_1 = Animator.StringToHash("Exit Phase 1");
        }

        [SerializeField] private Animator anim;
        [SerializeField] private Rigidbody2D rb;
        [SerializeField] private SpriteRenderer render;

        [Space(20f)]
        [SerializeField] private SkillData slashSkillData;
        [SerializeField] private SkillData ejectSlashSkillData;
        [SerializeField] private SkillData explosionSkillData;
        [SerializeField] private SkillData rushSkillData;

        [SerializeField] private Transform playerTr;

        private IBehaviourTreeNode bt;
        private OverheadUI overheadUI;
        private int phase = 1;
        private float nextActionTime; // 스킬의 후딜레이를 지정하기 위해 사용함. 게임의 시간 값이 할당 됨.
        private Skill currentSkill = Skill.None;
        private int currentPlayingAnim;
        private bool isInteractable = true;
        private Awaitable colorFadeAwaiter = null;
        private float colorFadeTime = 0.2f;

        protected override void Awake()
        {
            base.Awake();

            Init();

            this.gameObject.layer = LayerMask.NameToLayer(GameManager.INTERACTABLE_OBJECT_LAYER_NAME);
            if (this.gameObject.layer == -1)
            {
                Debug.LogError("레이어 이름 오류");
            }

            bt = GetBehaviourTree();
        }

        protected override void Start()
        {
            base.Start();

            overheadUI = GameManager.Instance.uiManager.overheadUI_Pool.Burrow<OverheadUI>();
            overheadUI.Init(this.transform, Vector3.zero);
            overheadUI.Enable();
        }

        protected override void Update()
        {
            base.Update();

            if (playerTr != null)
            {
                bt.Tick(new TimeData(Time.deltaTime));
            }
        }

        void ICombatable.TakeHit(float damage, BaseObject hitter)
        {
            if (isInteractable)
            {
                return;
            }

            hp -= damage;

            TakeHitVFX vfx = GameManager.Instance.combatSystem.GetTakeHitVFX();
            vfx.Init(this.transform.position + Vector3.down * 1f);
            vfx.Enable();

            if (colorFadeAwaiter != null)
            {
                colorFadeAwaiter.Cancel();
                colorFadeAwaiter = null;
            }

            colorFadeAwaiter = FadeColor();
        }
        
        private async Awaitable FadeColor()
        {
            float timer = Time.time + colorFadeTime;

            render.color = new Color(1f, 0f, 0f, 1f);

            while (Time.time < timer)
            {
                float color = Mathf.Lerp(0f, 1f, 1 - ((timer - Time.time) / colorFadeTime));
                render.color = new Color(1f, color, color, 1f);

                await Awaitable.NextFrameAsync();
            }

            render.color = new Color(1f, 1f, 1f, 1f);
        }

        void IInteractable.CancelInteraction()
        {
            // IsInteractable == True 일 때만 호출 가능.
            // 대화 취소했을 때 처리. 다시 대화 가능하게 설정.
            isInteractable = true;
        }

        bool IInteractable.IsInteractable()
        {
            // 처음 조우 했을 때 한번 대화 가능.
            return isInteractable;
        }

        void IInteractable.SetInteractionGuide(bool isActive)
        {
            // 상호작용 UI 노출
            overheadUI.ActiveG_Key(isActive);
        }

        void IInteractable.StartInteraction(Action interactionCallback)
        {
            // IsInteractable == true 일 때만 호출 가능.
            if (isInteractable)
            {
                if (GameManager.Instance.data.dialog.TryGetValue(4, out var dialogWrapper)) // 4번 다이얼로그 시작
                {
                    LookAt(Player.Current.transform.position);

                    // 다이얼로그 시작.
                    GameManager.Instance.uiManager.dialog.StartDialog(dialogWrapper.DialogTextList, () =>
                    {
                        playerTr = Player.Current.transform;
                        isInteractable = false;
                        this.gameObject.layer = LayerMask.NameToLayer(GameManager.MONSTER_SIDE_LAYER_NAME);

                        interactionCallback?.Invoke();
                    });

                    overheadUI.ActiveG_Key(false);
                }
            }
        }

        private void LookAt(Vector3 targetPos)
        {
            Vector3 dir = targetPos - this.transform.position;

            if (dir.x > 0f)
            {
                this.transform.rotation = Quaternion.Euler(0f, 0f, 0f);
            }
            else
            {
                this.transform.rotation = Quaternion.Euler(0f, 180f, 0f);
            }
        }

        #region Behaviour Tree

        [ContextMenu("BT 초기화 함수")]
        private void ResetBehaviourTree()
        {
            currentSkill = Skill.None;
            currentPlayingAnim = -1;
            phase = 1;
            nextActionTime = -1f;
            hp = info.hp;

            anim.Play(AnimHash.IDLE);
        }

        // 메인 Behaviour Tree 반환
        private IBehaviourTreeNode GetBehaviourTree()
        {
            var builder = new BehaviourTreeBuilder();

            // BT..
            builder.Selector(string.Empty)
                .Sequence(string.Empty) // 페이즈 체크
                    .Condition(string.Empty, t => hp <= 0f) // 체력이 0보다 작거나 같으면 페이즈 변경 시도
                    .Sequence(string.Empty)
                        .Do(string.Empty, t => // 페이즈 변경 시도
                        {
                            if (phase == 1)
                            {
                                phase = 2;
                                anim.Play(AnimHash.PHASE_EXIT_1);
                                currentPlayingAnim = AnimHash.PHASE_EXIT_1;
                            }

                            return BehaviourTreeStatus.Success;
                        })
                    .End()
                .End()

                .Sequence(string.Empty) // 메인 패턴 진입점
                    .Condition(string.Empty, t => Time.time > nextActionTime) // 스킬 사용 선제 조건 체크
                    .Sequence(string.Empty) // 준비중인 스킬이 없는 경우 랜덤하게 스킬 지정
                        .Do(string.Empty, t =>
                        {
                            if (currentSkill == Skill.None)
                            {
                                currentSkill = GetSkillRandomly();
                            }

                            return BehaviourTreeStatus.Success;
                        })
                    .End()

                    .Selector(string.Empty)
                        .Splice(GetSlashBehaviourTree())
                        .Splice(GetEjectSlashBehaviourTree())
                        .Splice(GetExplosionBehaviourTree())
                        .Splice(GetRushBehaviourTree())
                    .End()
                .End()

                .Do(string.Empty, t => // 플레이어를 바라보는 동작 처리.
                {
                    LookAt(playerTr.position);

                    anim.Play(AnimHash.IDLE);

                    return BehaviourTreeStatus.Success;
                })
            .End();

            return builder.Build();
        }

        /// <summary>
        /// 랜덤한 스킬을 반환하는 함수
        /// </summary>
        private Skill GetSkillRandomly()
        {
            System.Random random = new System.Random();

            int value = random.Next(0, 3);
            Skill result = Skill.None;

            switch (value)
            {
                case 0:
                {
                    result = Skill.Slash;
                    break;
                }
                case 1:
                {
                    result = Skill.EjectSlash;
                    break;
                }
                case 2:
                {
                    result = Skill.Explosion;
                    break;
                }
                case 3:
                {
                    result = Skill.Rush;
                    break;
                }
            }

            return result; // None이면 안됌.
        }

        // 공격 스킬 서브 트리 반환
        private IBehaviourTreeNode GetSlashBehaviourTree()
        {
            float afterDelay = 2f;
            float xDistance = 6f;

            BehaviourTreeBuilder builder = new BehaviourTreeBuilder();

            builder.Sequence(string.Empty)
                .Do(string.Empty, t =>
                {
                    if (currentSkill == Skill.Slash)
                        return BehaviourTreeStatus.Success;
                    else
                        return BehaviourTreeStatus.Failure;
                })
                .Do(string.Empty, t => // 애니메이터와 스크립트 간의 싱크 테스트
                {
                    if (currentPlayingAnim != AnimHash.SLASH) // Play 메서드를 호출하려는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                    else if (anim.GetCurrentAnimatorStateInfo(0).shortNameHash != AnimHash.SLASH) // Play 메서드가 호출 되었고, 동기화가 이루어지지 않은 시점.
                    {
                        return BehaviourTreeStatus.Failure;
                    }
                    else  // Play 메서드가 호출되었고, 애니메이터와 싱크가 일치하는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                })
                .Selector(string.Empty)
                    .Do(string.Empty, t =>
                    {
                        if (currentPlayingAnim != AnimHash.SLASH) // 현재 재생중인 애니메이션이 폭파가 아닌 경우
                            return BehaviourTreeStatus.Failure;

                        if (anim.GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f) // 폭파 애니메이션이 끝난 경우
                        {
                            currentSkill = Skill.None;
                            nextActionTime = Time.time + afterDelay;

                            anim.Play(AnimHash.IDLE);
                            currentPlayingAnim = AnimHash.IDLE;

                            return BehaviourTreeStatus.Success;
                        }
                        else
                        {
                            return BehaviourTreeStatus.Running;
                        }
                    })

                    .Selector(string.Empty)
                        .Do(string.Empty, t => // 애니메이션의 시점.
                        {
                            if (Mathf.Abs(playerTr.position.x - transform.position.x) < xDistance) // 사정거리 조건
                            {
                                anim.Play(AnimHash.SLASH);
                                currentPlayingAnim = AnimHash.SLASH;

                                var skill = GameManager.Instance.combatSystem.GetSkill();
                                skill.Init(transform.position, transform.rotation, transform.gameObject.layer, slashSkillData, this);
                                skill.Enable();

                                return BehaviourTreeStatus.Running;
                            }
                            else
                            {
                                return BehaviourTreeStatus.Failure;
                            }
                        })

                        .Do(string.Empty, t => // 플레이어쪽으로 이동
                        {
                            Vector3 dir = playerTr.position - transform.position;

                            // 좌우 회전
                            if (dir.x > 0f)
                            {
                                transform.rotation = Quaternion.identity;
                            }
                            else
                            {
                                transform.rotation = Quaternion.Euler(0f, 180f, 0f);
                            }

                            rb.linearVelocityX = Mathf.Sign(dir.x) * info.speed;

                            anim.Play(AnimHash.MOVE);
                            currentPlayingAnim = AnimHash.MOVE;

                            return BehaviourTreeStatus.Running;
                        })
                    .End()
                .End()
            .End();

            return builder.Build();
        }

        public float speed = 5f;

        // 공격 스킬 서브 트리 반환
        private IBehaviourTreeNode GetEjectSlashBehaviourTree()
        {
            float afterDelay = 2f;
            float xDistance = 60f;

            BehaviourTreeBuilder builder = new BehaviourTreeBuilder();

            builder.Sequence(string.Empty)
                .Do(string.Empty, t =>
                {
                    if (currentSkill == Skill.EjectSlash)
                        return BehaviourTreeStatus.Success;
                    else
                        return BehaviourTreeStatus.Failure;
                })
                .Do(string.Empty, t => // 애니메이터와 스크립트 간의 싱크 테스트
                {
                    if (currentPlayingAnim != AnimHash.EJECT_SLASH) // Play 메서드를 호출하려는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                    else if (anim.GetCurrentAnimatorStateInfo(0).shortNameHash != AnimHash.EJECT_SLASH) // Play 메서드가 호출 되었고, 동기화가 이루어지지 않은 시점.
                    {
                        return BehaviourTreeStatus.Failure;
                    }
                    else  // Play 메서드가 호출되었고, 애니메이터와 싱크가 일치하는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                })
                .Selector(string.Empty)
                    .Do(string.Empty, t =>
                    {
                        if (currentPlayingAnim != AnimHash.EJECT_SLASH) // 현재 재생중인 애니메이션이 폭파가 아닌 경우
                            return BehaviourTreeStatus.Failure;

                        if (anim.GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f) // 폭파 애니메이션이 끝난 경우
                        {
                            currentSkill = Skill.None;
                            nextActionTime = Time.time + afterDelay;

                            anim.Play(AnimHash.IDLE);
                            currentPlayingAnim = AnimHash.IDLE;

                            return BehaviourTreeStatus.Success;
                        }
                        else
                        {
                            return BehaviourTreeStatus.Running;
                        }
                    })

                    .Selector(string.Empty)
                        .Do(string.Empty, t => // 애니메이션의 시점.
                        {
                            if (Mathf.Abs(playerTr.position.x - transform.position.x) < xDistance) // 사정거리 조건
                            {
                                anim.Play(AnimHash.EJECT_SLASH);
                                currentPlayingAnim = AnimHash.EJECT_SLASH;

                                Vector2 dir = new Vector2((playerTr.position - transform.position).x, 0f);

                                var ejectingSkill = GameManager.Instance.combatSystem.GetLinearDynamicSkill();
                                ejectingSkill.Init(transform.position, transform.rotation, transform.gameObject.layer, ejectSlashSkillData, this, dir.normalized * speed);
                                ejectingSkill.Enable();

                                return BehaviourTreeStatus.Running;
                            }
                            else
                            {
                                return BehaviourTreeStatus.Failure;
                            }
                        })

                        .Do(string.Empty, t => // 플레이어쪽으로 이동
                        {
                            Vector3 dir = playerTr.position - transform.position;

                            LookAt(playerTr.position);

                            rb.linearVelocityX = Mathf.Sign(dir.x) * info.speed;

                            anim.Play(AnimHash.MOVE);
                            currentPlayingAnim = AnimHash.MOVE;

                            return BehaviourTreeStatus.Running;
                        })
                    .End()
                .End()
            .End();

            return builder.Build();
        }

        // 공격 스킬 서브 트리 반환
        private IBehaviourTreeNode GetExplosionBehaviourTree()
        {
            float afterDelay = 2f;
            float xDistance = 10f;

            BehaviourTreeBuilder builder = new BehaviourTreeBuilder();

            builder.Sequence(string.Empty)
                .Do(string.Empty, t =>
                {
                    if (currentSkill == Skill.Explosion)
                        return BehaviourTreeStatus.Success;
                    else
                        return BehaviourTreeStatus.Failure;
                })
                .Do(string.Empty, t => // 애니메이터와 스크립트 간의 싱크 테스트
                {
                    if (currentPlayingAnim != AnimHash.EXPLOSION) // Play 메서드를 호출하려는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                    else if (anim.GetCurrentAnimatorStateInfo(0).shortNameHash != AnimHash.EXPLOSION) // Play 메서드가 호출 되었고, 동기화가 이루어지지 않은 시점.
                    {
                        return BehaviourTreeStatus.Failure;
                    }
                    else  // Play 메서드가 호출되었고, 애니메이터와 싱크가 일치하는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                })
                .Selector(string.Empty)
                    .Do(string.Empty, t =>
                    {
                        if (currentPlayingAnim != AnimHash.EXPLOSION) // 현재 재생중인 애니메이션이 폭파가 아닌 경우
                            return BehaviourTreeStatus.Failure;

                        if (anim.GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f) // 폭파 애니메이션이 끝난 경우
                        {
                            currentSkill = Skill.None;
                            nextActionTime = Time.time + afterDelay;

                            anim.Play(AnimHash.IDLE);
                            currentPlayingAnim = AnimHash.IDLE;

                            return BehaviourTreeStatus.Success;
                        }
                        else
                        {
                            return BehaviourTreeStatus.Running;
                        }
                    })

                    .Selector(string.Empty)
                        .Do(string.Empty, t => // 애니메이션의 시점.
                        {
                            if (Mathf.Abs(playerTr.position.x - transform.position.x) < xDistance) // 사정거리 조건
                            {
                                anim.Play(AnimHash.EXPLOSION);
                                currentPlayingAnim = AnimHash.EXPLOSION;

                                var skill = GameManager.Instance.combatSystem.GetSkill();
                                skill.Init(transform.position, transform.rotation, transform.gameObject.layer, explosionSkillData, this);
                                skill.Enable();

                                return BehaviourTreeStatus.Running;
                            }
                            else
                            {
                                return BehaviourTreeStatus.Failure;
                            }
                        })

                        .Do(string.Empty, t => // 플레이어쪽으로 이동
                        {
                            Vector3 dir = playerTr.position - transform.position;

                            LookAt(playerTr.position);

                            rb.linearVelocityX = Mathf.Sign(dir.x) * info.speed;

                            anim.Play(AnimHash.MOVE);
                            currentPlayingAnim = AnimHash.MOVE;

                            return BehaviourTreeStatus.Running;
                        })
                    .End()
                .End()
            .End();

            return builder.Build();
        }

        // 공격 스킬 서브 트리 반환
        private IBehaviourTreeNode GetRushBehaviourTree()
        {
            float afterDelay = 2f;
            float xDistance = 60f;

            BehaviourTreeBuilder builder = new BehaviourTreeBuilder();

            builder.Sequence(string.Empty)
                .Do(string.Empty, t =>
                {
                    if (currentSkill == Skill.Rush)
                        return BehaviourTreeStatus.Success;
                    else
                        return BehaviourTreeStatus.Failure;
                })
                .Do(string.Empty, t => // 애니메이터와 스크립트 간의 싱크 테스트
                {
                    if (currentPlayingAnim != AnimHash.RUSH) // Play 메서드를 호출하려는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                    else if (anim.GetCurrentAnimatorStateInfo(0).shortNameHash != AnimHash.RUSH) // Play 메서드가 호출 되었고, 동기화가 이루어지지 않은 시점.
                    {
                        return BehaviourTreeStatus.Failure;
                    }
                    else  // Play 메서드가 호출되었고, 애니메이터와 싱크가 일치하는 시점.
                    {
                        return BehaviourTreeStatus.Success;
                    }
                })
                .Selector(string.Empty)
                    .Do(string.Empty, t =>
                    {
                        if (currentPlayingAnim != AnimHash.RUSH) // 현재 재생중인 애니메이션이 폭파가 아닌 경우
                            return BehaviourTreeStatus.Failure;

                        if (anim.GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f) // 폭파 애니메이션이 끝난 경우
                        {
                            currentSkill = Skill.None;
                            nextActionTime = Time.time + afterDelay;

                            anim.Play(AnimHash.IDLE);
                            currentPlayingAnim = AnimHash.IDLE;

                            return BehaviourTreeStatus.Success;
                        }
                        else
                        {
                            return BehaviourTreeStatus.Running;
                        }
                    })

                    .Selector(string.Empty)
                        .Do(string.Empty, t => // 애니메이션의 시점.
                        {
                            if (Mathf.Abs(playerTr.position.x - transform.position.x) < xDistance) // 사정거리 조건
                            {
                                anim.Play(AnimHash.RUSH);
                                currentPlayingAnim = AnimHash.RUSH;

                                var skill = GameManager.Instance.combatSystem.GetSkill();
                                skill.Init(transform.position, transform.rotation, transform.gameObject.layer, rushSkillData, this);
                                skill.Enable();

                                return BehaviourTreeStatus.Running;
                            }
                            else
                            {
                                return BehaviourTreeStatus.Failure;
                            }
                        })

                        .Do(string.Empty, t => // 플레이어쪽으로 이동
                        {
                            Vector3 dir = playerTr.position - transform.position;

                            LookAt(playerTr.position);

                            rb.linearVelocityX = Mathf.Sign(dir.x) * info.speed;

                            anim.Play(AnimHash.MOVE);
                            currentPlayingAnim = AnimHash.MOVE;

                            return BehaviourTreeStatus.Running;
                        })
                    .End()
                .End()
            .End();

            return builder.Build();
        }

        #endregion
    }
}